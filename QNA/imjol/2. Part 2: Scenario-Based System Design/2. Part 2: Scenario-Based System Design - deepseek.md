Part 2: Scenario-Based System Design
Scenario 1 – Handling Real-Time Webhook Overload
Your product integrates with a third-party ML service for video generation. During peak usage, you start receiving 1,500 webhook requests per minute, causing delays and missed events.
How would you redesign your architecture to handle this spike reliably?


Which queuing/concurrency strategies would you use?


How would you handle error retries and resiliency?


How would you prioritize urgent jobs (e.g., password reset emails) vs. lower-priority jobs (e.g., video generation)?


solv: 
--------------------------

Excellent choice! This is a robust and production-ready stack. Let me break down the solution with ASCII diagrams and detailed explanations.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Docker Swarm Cluster                     │
├─────────────────┬─────────────────┬─────────────────┬───────────┤
│   Load Balancer │   Message Queue │   API Workers   │  Database │
│    (NGINX)      │   (RabbitMQ)    │   (Laravel)     │ (Optional)│
└─────────────────┴─────────────────┴─────────────────┴───────────┘
```

## Detailed ASCII Flow

```
                                                                   ┌─────────────────┐
                                                                   │ Third-Party ML  │
                                                                   │    Service      │
                                                                   └─────────────────┘
                                                                           ↓
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            DOCKER SWARM CLUSTER                                │
├───────────────────┬─────────────────┬─────────────────┬─────────────────────┤
│    NGINX Service  │  RabbitMQ Service │ Laravel API Service  │  Database Service │
│  ┌──────────────┐ │  ┌─────────────┐  │  ┌───────────────┐   │  ┌─────────────┐   │
│  │  webhook-api │ │  │   Queue     │  │  │   Consumer    │   │  │   MySQL/    │   │
│  │   :80        │ │  │  (Durable)  │  │  │   Workers     │   │  │  PostgreSQL │   │
│  └──────────────┘ │  └─────────────┘  │  └───────────────┘   │  └─────────────┘   │
│         ↑         │         ↑         │          ↑           │          ↑         │
│  Load Balancer    │  Message Broker   │   Background Jobs    │   Data Storage     │
└───────────────────┴─────────────────┴─────────────────┴─────────────────────┘
         ↓                   ↓                     ↓                     ↓
   Fast Response       Buffered Events      Async Processing      State Management
```

## Step-by-Step Implementation

### Step 1: Webhook Reception (NGINX)

```
┌─────────────────────────────────────────┐
│              NGINX Service              │
├─────────────────────────────────────────┤
│ 1. Receive Webhook (1500/min)          │
│ 2. Validate Signature                  │
│ 3. Rate Limiting (if needed)           │
│ 4. Forward to Laravel API              │
│ 5. Immediate 200 OK Response           │
└─────────────────────────────────────────┘
```

**docker-compose.yml snippet:**
```yaml
version: '3.8'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    deploy:
      replicas: 2
      restart_policy:
        condition: any
    networks:
      - app-network

  laravel_api:
    image: your-laravel-app:latest
    deploy:
      replicas: 3
      restart_policy:
        condition: any
    environment:
      - RABBITMQ_HOST=rabbitmq
      - QUEUE_CONNECTION=rabbitmq
    networks:
      - app-network
    depends_on:
      - rabbitmq
```

**nginx.conf:**
```nginx
events {
    worker_connections 4096;
}

http {
    upstream laravel_backend {
        server laravel_api:9000;
    }

    server {
        listen 80;
        server_name webhook-api.example.com;

        client_max_body_size 100M;
        client_body_timeout 10s;

        location /webhook {
            # Rate limiting (optional)
            limit_req zone=webhooks burst=100 nodelay;
            
            # Fast proxy to Laravel
            proxy_pass http://laravel_backend;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;
            
            # Headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }

    limit_req_zone $binary_remote_addr zone=webhooks:10m rate=1000r/s;
}
```

### Step 2: Message Queue (RabbitMQ)

```
┌─────────────────────────────────────────┐
│            RabbitMQ Service             │
├─────────────────────────────────────────┤
│  Exchange: webhook_events               │
│  Queue: video_generation_queue (Durable)│
│  DLX: dead_letter_exchange              │
│  Queue: dead_letter_queue               │
└─────────────────────────────────────────┘
```

**docker-compose.yml continuation:**
```yaml
  rabbitmq:
    image: rabbitmq:3-management
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=securepassword
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    ports:
      - "15672:15672"  # Management UI
    deploy:
      replicas: 1
      placement:
        constraints: [node.role == manager]
    networks:
      - app-network

volumes:
  rabbitmq_data:
```

### Step 3: Laravel API Processing

```
┌─────────────────────────────────────────┐
│           Laravel API Service           │
├─────────────────────────────────────────┤
│  A. Webhook Controller:                 │
│     1. Validate payload                 │
│     2. Push to RabbitMQ                 │
│     3. Return 200 OK                    │
│                                         │
│  B. Queue Workers:                      │
│     1. Consume from RabbitMQ            │
│     2. Process video generation         │
│     3. Handle retries with backoff      │
│     4. Move failures to DLQ             │
└─────────────────────────────────────────┘
```

**Laravel Controller:**
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Http\Response;
use App\Jobs\ProcessVideoGeneration;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Queue;

class WebhookController extends Controller
{
    public function handleWebhook(Request $request)
    {
        // 1. Validate webhook signature
        if (!$this->verifySignature($request)) {
            Log::warning('Invalid webhook signature', [
                'ip' => $request->ip()
            ]);
            return response()->json(['error' => 'Invalid signature'], 401);
        }

        // 2. Validate payload structure
        $validated = $request->validate([
            'video_id' => 'required|string',
            'status' => 'required|string',
            'download_url' => 'nullable|url',
            'metadata' => 'nullable|array'
        ]);

        // 3. Immediately queue the job for async processing
        ProcessVideoGeneration::dispatch($validated)
            ->onQueue('video_generation');

        Log::info('Webhook queued successfully', [
            'video_id' => $validated['video_id'],
            'queue' => 'video_generation'
        ]);

        // 4. Return immediate response
        return response()->json([
            'status' => 'queued',
            'message' => 'Webhook received and queued for processing'
        ], 200);
    }

    private function verifySignature(Request $request): bool
    {
        // Implement your signature verification logic
        $signature = $request->header('X-Signature');
        $payload = $request->getContent();
        
        $expected = hash_hmac('sha256', $payload, config('services.ml.webhook_secret'));
        
        return hash_equals($expected, $signature);
    }
}
```

**Laravel Job with Retry Logic:**
```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Throwable;

class ProcessVideoGeneration implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, SerializesModels;

    public $tries = 3;
    public $maxExceptions = 2;
    public $timeout = 120;
    public $backoff = [10, 30, 60];

    protected $webhookData;

    public function __construct(array $webhookData)
    {
        $this->webhookData = $webhookData;
        $this->onQueue('video_generation');
    }

    public function handle()
    {
        Log::info('Processing video generation job', [
            'video_id' => $this->webhookData['video_id'],
            'attempt' => $this->attempts()
        ]);

        // 1. Update database status
        $this->updateVideoStatus('processing');

        // 2. Download video if URL provided
        if (isset($this->webhookData['download_url'])) {
            $this->downloadAndStoreVideo();
        }

        // 3. Process video metadata
        $this->processVideoMetadata();

        // 4. Update final status
        $this->updateVideoStatus('completed');

        Log::info('Video processing completed', [
            'video_id' => $this->webhookData['video_id']
        ]);
    }

    public function failed(Throwable $exception)
    {
        Log::error('Video processing job failed', [
            'video_id' => $this->webhookData['video_id'],
            'error' => $exception->getMessage(),
            'attempts' => $this->attempts()
        ]);

        // Move to dead letter queue or mark as failed in database
        $this->updateVideoStatus('failed');
    }

    private function downloadAndStoreVideo()
    {
        try {
            $response = Http::timeout(60)
                ->retry(3, 1000)
                ->get($this->webhookData['download_url']);

            if ($response->successful()) {
                // Store video file (S3, local storage, etc.)
                $filename = $this->webhookData['video_id'] . '.mp4';
                file_put_contents(storage_path('app/videos/' . $filename), $response->body());
                
                Log::info('Video downloaded successfully', [
                    'video_id' => $this->webhookData['video_id'],
                    'filename' => $filename
                ]);
            }
        } catch (\Exception $e) {
            Log::error('Video download failed', [
                'video_id' => $this->webhookData['video_id'],
                'error' => $e->getMessage()
            ]);
            throw $e; // Re-throw to trigger job retry
        }
    }

    private function updateVideoStatus($status)
    {
        // Update your database with the new status
        \App\Models\Video::where('video_id', $this->webhookData['video_id'])
            ->update(['status' => $status]);
    }

    private function processVideoMetadata()
    {
        // Process any additional metadata
        if (isset($this->webhookData['metadata'])) {
            // Your metadata processing logic here
        }
    }
}
```

### Step 4: Docker Swarm Deployment

```
┌─────────────────────────────────────────────────────────────────┐
│                    Docker Swarm Stack                          │
├───────────────────┬─────────────────┬─────────────────────────┤
│   Service Stack:  │   Scaling:      │    Network:             │
│   - nginx (2)     │   - Auto-scale  │    - Overlay network    │
│   - laravel (3+)  │     based on    │    - Internal comm      │
│   - rabbitmq (1)  │     queue depth │    - Load balancing     │
│   - mysql (1)     │   - Health checks│                         │
└───────────────────┴─────────────────┴─────────────────────────┘
```

**docker-stack.yml:**
```yaml
version: '3.8'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    configs:
      - source: nginx_config
        target: /etc/nginx/nginx.conf
    deploy:
      replicas: 2
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: any
        delay: 5s
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

  laravel_api:
    image: your-org/laravel-webhook-api:latest
    deploy:
      replicas: 3
      update_config:
        parallelism: 2
        delay: 15s
      restart_policy:
        condition: any
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    environment:
      - RABBITMQ_HOST=rabbitmq
      - DB_HOST=mysql
      - QUEUE_CONNECTION=rabbitmq
    depends_on:
      - rabbitmq
      - mysql

  rabbitmq:
    image: rabbitmq:3-management-alpine
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
    deploy:
      replicas: 1
      placement:
        constraints: [node.role == manager]
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}
      - MYSQL_DATABASE=webhook_db
    deploy:
      replicas: 1
      placement:
        constraints: [node.role == manager]
    volumes:
      - mysql_data:/var/lib/mysql

  queue_worker:
    image: your-org/laravel-webhook-api:latest
    command: ["php", "artisan", "queue:work", "--queue=video_generation", "--tries=3", "--timeout=120"]
    deploy:
      replicas: 5
      restart_policy:
        condition: any
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M
    environment:
      - RABBITMQ_HOST=rabbitmq
      - QUEUE_CONNECTION=rabbitmq

configs:
  nginx_config:
    file: ./nginx.conf

volumes:
  rabbitmq_data:
  mysql_data:

networks:
  default:
    driver: overlay
```

## Complete Flow Summary

```
1. Webhook Received
   ↓
2. NGINX (Load Balancer) → Fast 200 OK
   ↓
3. Laravel API → Validate → Queue to RabbitMQ
   ↓
4. RabbitMQ (Buffer) → Durable Storage
   ↓
5. Laravel Queue Workers → Consume & Process
   ↓
6. Database → Update Status
   ↓
7. (If Failure) → Retry with Backoff → DLQ
```

## Key Benefits of This Stack

- **NGINX**: Efficient load balancing and SSL termination
- **RabbitMQ**: Reliable message buffering and delivery guarantees
- **Laravel**: Robust job handling with built-in retry mechanisms
- **Docker Swarm**: Easy scaling and high availability
- **Dead Letter Queue**: Automatic handling of poison messages

This architecture can easily handle 1,500+ webhooks per minute with proper resource allocation and scaling configuration.

Question : How would you prioritize urgent jobs (e.g., password reset emails) vs. lower-priority jobs (e.g., video generation)?
----------
Excellent question! Priority handling is crucial for a robust system. Here's how to implement job prioritization in your RabbitMQ + Laravel + Docker Swarm stack:

## Priority Queue Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    RabbitMQ Priority Setup                     │
├───────────────────┬─────────────────┬─────────────────────────┤
│    High Priority  │  Medium Priority│    Low Priority         │
│    Queue (10)     │   Queue (5)     │    Queue (0)            │
├───────────────────┼─────────────────┼─────────────────────────┤
│ • Password Reset  │ • Notifications │ • Video Generation      │
│ • Payment Processing│ • Email Campaigns│ • Data Export         │
│ • Critical Alerts │ • User Activity │ • Report Generation     │
│ • Real-time Sync  │ • API Sync      │ • Bulk Operations       │
└───────────────────┴─────────────────┴─────────────────────────┘
```

## ASCII Architecture Flow

```
┌─────────────────┐    ┌───────────────────────────────────┐
│   Laravel API   │    │         RabbitMQ Queues           │
│                 │    │                                   │
│  ┌─────────────┐│    │  ┌─────┐  ┌─────┐  ┌─────┐       │
│  │   Dispatch  ││───▶│  │High │  │Med  │  │Low  │       │
│  │  with       ││    │  │(10) │  │(5)  │  │(0)  │       │
│  │  Priority   ││    │  └─────┘  └─────┘  └─────┘       │
│  └─────────────┘│    │                                   │
└─────────────────┘    └───────────────────────────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │   Priority Workers      │
                    │                         │
                    │  ┌───────────────────┐  │
                    │  │  Consumption      │  │
                    │  │  Order:           │  │
                    │  │  1. High (10)     │  │
                    │  │  2. Medium (5)    │  │
                    │  │  3. Low (0)       │  │
                    │  └───────────────────┘  │
                    └─────────────────────────┘
```

## Step 1: RabbitMQ Queue Configuration

**docker-compose.yml with Priority Queues:**
```yaml
version: '3.8'

services:
  rabbitmq:
    image: rabbitmq:3-management
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=securepassword
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - ./rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf
    deploy:
      replicas: 1
      placement:
        constraints: [node.role == manager]

  # Priority-based worker services
  worker_high:
    image: your-laravel-app:latest
    command: ["php", "artisan", "queue:work", "rabbitmq", "--queue=high,medium,low", "--sleep=0", "--tries=3", "--timeout=60"]
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 256M
    environment:
      - QUEUE_CONNECTION=rabbitmq
      - RABBITMQ_HOST=rabbitmq

  worker_low:
    image: your-laravel-app:latest
    command: ["php", "artisan", "queue:work", "rabbitmq", "--queue=low,medium,high", "--sleep=1", "--tries=1", "--timeout=300"]
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
    environment:
      - QUEUE_CONNECTION=rabbitmq
      - RABBITMQ_HOST=rabbitmq
```

## Step 2: Laravel Job Priority Configuration

**config/queue.php:**
```php
<?php

return [
    'connections' => [
        'rabbitmq' => [
            'driver' => 'rabbitmq',
            'queue' => env('RABBITMQ_QUEUE', 'low'),
            'connection' => PhpAmqpLib\Connection\AMQPLazyConnection::class,
            'hosts' => [
                [
                    'host' => env('RABBITMQ_HOST', '127.0.0.1'),
                    'port' => env('RABBITMQ_PORT', 5672),
                    'user' => env('RABBITMQ_USER', 'guest'),
                    'password' => env('RABBITMQ_PASSWORD', 'guest'),
                    'vhost' => env('RABBITMQ_VHOST', '/'),
                ],
            ],
            'options' => [
                'ssl_options' => [
                    'cafile' => env('RABBITMQ_SSL_CAFILE', null),
                    'local_cert' => env('RABBITMQ_SSL_LOCALCERT', null),
                    'local_key' => env('RABBITMQ_SSL_LOCALKEY', null),
                    'verify_peer' => env('RABBITMQ_SSL_VERIFY_PEER', true),
                    'passphrase' => env('RABBITMQ_SSL_PASSPHRASE', null),
                ],
                'queue' => [
                    'job_release' => env('RABBITMQ_JOB_RELEASE', 'reject'),
                    'priorities' => [
                        'high' => 10,
                        'medium' => 5,
                        'low' => 0,
                    ],
                ],
            ],
        ],
    ],
];
```

## Step 3: Priority-Based Job Classes

**High Priority Job (Password Reset):**
```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Mail;
use App\Mail\PasswordResetEmail;

class ProcessPasswordReset implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, SerializesModels;

    public $tries = 5;
    public $timeout = 30;
    public $maxExceptions = 2;
    public $backoff = [1, 5, 10]; // Seconds

    protected $user;
    protected $token;

    public function __construct($user, $token)
    {
        $this->user = $user;
        $this->token = $token;
        
        // Set high priority
        $this->onQueue('high');
        
        // Ensure immediate processing
        $this->delay = 0;
    }

    public function handle()
    {
        try {
            // Send password reset email immediately
            Mail::to($this->user->email)
                ->send(new PasswordResetEmail($this->user, $this->token));

            \Log::info('Password reset email sent', [
                'user_id' => $this->user->id,
                'email' => $this->user->email,
                'queue' => 'high'
            ]);

        } catch (\Exception $e) {
            \Log::error('Password reset failed', [
                'user_id' => $this->user->id,
                'error' => $e->getMessage()
            ]);
            
            // Retry quickly for high priority jobs
            $this->release(1);
        }
    }

    public function failed(\Throwable $exception)
    {
        \Log::critical('Password reset job failed after all retries', [
            'user_id' => $this->user->id,
            'error' => $exception->getMessage()
        ]);
        
        // Notify admins about critical failure
        // Notification::send($admins, new CriticalJobFailed($this->user, $exception));
    }
}
```

**Medium Priority Job (Notifications):**
```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessNotification implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, SerializesModels;

    public $tries = 3;
    public $timeout = 60;
    public $backoff = [10, 30, 60];

    protected $notification;
    protected $users;

    public function __construct($notification, $users)
    {
        $this->notification = $notification;
        $this->users = $users;
        
        // Set medium priority
        $this->onQueue('medium');
    }

    public function handle()
    {
        // Process notification logic
        foreach ($this->users as $user) {
            // Send notification
            $user->notify($this->notification);
        }

        \Log::info('Notifications processed', [
            'type' => get_class($this->notification),
            'users_count' => count($this->users),
            'queue' => 'medium'
        ]);
    }
}
```

**Low Priority Job (Video Generation):**
```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessVideoGeneration implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, SerializesModels;

    public $tries = 1; // Fewer retries for low priority
    public $timeout = 1800; // 30 minutes timeout
    public $backoff = [60, 300, 900]; // Longer backoff

    protected $webhookData;

    public function __construct(array $webhookData)
    {
        $this->webhookData = $webhookData;
        
        // Set low priority - can wait
        $this->onQueue('low');
        
        // Can be delayed if needed
        $this->delay = now()->addMinutes(5);
    }

    public function handle()
    {
        \Log::info('Processing video generation (low priority)', [
            'video_id' => $this->webhookData['video_id'],
            'queue' => 'low'
        ]);

        // Long-running video processing logic
        $this->downloadAndProcessVideo();
        $this->updateVideoStatus('completed');
    }

    public function failed(\Throwable $exception)
    {
        \Log::warning('Video generation failed (low priority)', [
            'video_id' => $this->webhookData['video_id'],
            'error' => $exception->getMessage()
        ]);
        
        // Mark as failed but don't send urgent alerts
        $this->updateVideoStatus('failed');
    }
}
```

## Step 4: Docker Swarm with Priority-Based Scaling

**docker-stack.yml with Priority Workers:**
```yaml
version: '3.8'

services:
  # High Priority Workers - More resources, faster scaling
  worker_high:
    image: your-laravel-app:latest
    command: [
      "php", "artisan", "queue:work", "rabbitmq",
      "--queue=high,medium,low",
      "--sleep=0",
      "--tries=5",
      "--timeout=30",
      "--max-jobs=1000",
      "--memory=128"
    ]
    deploy:
      replicas: 5  # More workers for high priority
      update_config:
        parallelism: 2
        delay: 5s
      restart_policy:
        condition: any
        delay: 2s
        max_attempts: 10
        window: 30s
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
        reservations:
          memory: 128M
          cpus: '0.2'
    environment:
      - QUEUE_CONNECTION=rabbitmq
      - RABBITMQ_HOST=rabbitmq

  # Low Priority Workers - Fewer resources, slower scaling
  worker_low:
    image: your-laravel-app:latest
    command: [
      "php", "artisan", "queue:work", "rabbitmq", 
      "--queue=low,medium,high",
      "--sleep=1",
      "--tries=1",
      "--timeout=1800",
      "--max-jobs=100",
      "--memory=512"
    ]
    deploy:
      replicas: 2  # Fewer workers for low priority
      update_config:
        parallelism: 1
        delay: 30s
      restart_policy:
        condition: any
        delay: 10s
      resources:
        limits:
          memory: 1G  # More memory for video processing
          cpus: '1.0'
        reservations:
          memory: 512M
          cpus: '0.5'
    environment:
      - QUEUE_CONNECTION=rabbitmq
      - RABBITMQ_HOST=rabbitmq

  # Auto-scaling service for queue monitoring
  queue_monitor:
    image: your-laravel-app:latest
    command: ["php", "artisan", "queue:monitor", "high:50,medium:100,low:200"]
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
    environment:
      - RABBITMQ_HOST=rabbitmq
```

## Step 5: Queue Monitoring and Auto-Scaling

**Laravel Command for Queue Monitoring:**
```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class MonitorQueues extends Command
{
    protected $signature = 'queue:monitor {thresholds}';
    protected $description = 'Monitor queue sizes and auto-scale workers';

    public function handle()
    {
        $thresholds = $this->parseThresholds($this->argument('thresholds'));
        
        foreach ($thresholds as $queue => $threshold) {
            $size = $this->getQueueSize($queue);
            
            if ($size > $threshold) {
                $this->scaleWorkers($queue, $size, $threshold);
            }
        }
    }

    private function parseThresholds($thresholdsString)
    {
        // Format: "high:50,medium:100,low:200"
        $parts = explode(',', $thresholdsString);
        $thresholds = [];
        
        foreach ($parts as $part) {
            list($queue, $threshold) = explode(':', $part);
            $thresholds[$queue] = (int)$threshold;
        }
        
        return $thresholds;
    }

    private function getQueueSize($queue)
    {
        // Use RabbitMQ HTTP API to get queue size
        $response = Http::withBasicAuth(
            config('queue.connections.rabbitmq.options.user'),
            config('queue.connections.rabbitmq.options.password')
        )->get("http://rabbitmq:15672/api/queues/%2f/{$queue}");

        return $response->json('messages', 0);
    }

    private function scaleWorkers($queue, $currentSize, $threshold)
    {
        $scaleFactor = ceil($currentSize / $threshold);
        $newReplicas = min($scaleFactor * 2, 10); // Max 10 replicas
        
        Log::info("Scaling {$queue} workers", [
            'queue' => $queue,
            'current_size' => $currentSize,
            'threshold' => $threshold,
            'new_replicas' => $newReplicas
        ]);

        // Use Docker Swarm API to scale services
        // This would integrate with your orchestration tool
        $this->updateServiceReplicas("worker_{$queue}", $newReplicas);
    }
}
```

## Step 6: Job Dispatch with Priority

**Usage in Controllers:**
```php
<?php

namespace App\Http\Controllers;

use App\Jobs\ProcessPasswordReset;
use App\Jobs\ProcessVideoGeneration;
use App\Jobs\ProcessNotification;

class JobController extends Controller
{
    public function resetPassword(Request $request)
    {
        // High priority - immediate processing
        ProcessPasswordReset::dispatch($user, $token);
        
        return response()->json(['message' => 'Password reset initiated']);
    }

    public function handleVideoWebhook(Request $request)
    {
        // Low priority - can wait
        ProcessVideoGeneration::dispatch($request->all())
            ->onQueue('low');
            
        return response()->json(['message' => 'Video processing queued']);
    }

    public function sendNotifications(Request $request)
    {
        // Medium priority
        ProcessNotification::dispatch($notification, $users)
            ->onQueue('medium');
            
        return response()->json(['message' => 'Notifications queued']);
    }
}
```

## Summary of Priority Strategy

| Priority | Queue | Workers | Retries | Timeout | Use Cases |
|----------|-------|---------|---------|---------|-----------|
| **High** | `high` | 5 replicas | 5 tries | 30s | Password reset, payments, critical alerts |
| **Medium** | `medium` | 3 replicas | 3 tries | 60s | Notifications, emails, user activities |
| **Low** | `low` | 2 replicas | 1 try | 1800s | Video generation, reports, bulk operations |

**Key Benefits:**
- ✅ Urgent jobs (password reset) processed immediately
- ✅ System resources allocated based on business priority
- ✅ No starvation - low priority jobs still get processed
- ✅ Auto-scaling based on queue depth and priority
- ✅ Better user experience for critical operations

This strategy ensures that your most important jobs always get the resources they need while still processing less critical jobs efficiently.


